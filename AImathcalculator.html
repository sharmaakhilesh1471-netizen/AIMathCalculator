<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Handwritten Math Calculator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" xintegrity="sha384-n8MVd4RsNIU07EWpWcLsxgCUDGtopicfxicbOTTCFNJfhrHyYDCJQ2dMzV/GSnM" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" xintegrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
    <style>
        @import url('https://rsms.me/inter/inter.css');
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        canvas {
            touch-action: none; /* Prevents scrolling on touch devices while drawing */
            cursor: crosshair;
        }
        /* KaTeX font size adjustment */
        .katex { font-size: 1.25em; }
        .katex .text-slate-400 { color: #94a3b8; }
        
        /* Spinner animation */
        .spinner {
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .solution-step {
            padding: 8px 0;
            border-bottom: 1px solid #e2e8f0;
        }
        .solution-step:last-child {
            border-bottom: none;
        }
    </style>
</head>
<body class="bg-slate-100 text-slate-800">

    <div class="min-h-screen container mx-auto p-4 sm:p-6 lg:p-8">
        <header class="text-center mb-8">
            <h1 class="text-4xl md:text-5xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-purple-600 to-indigo-600">
                AI Math Vision
            </h1>
            <p class="mt-2 text-slate-600 max-w-2xl mx-auto">Draw a mathematical expression, and let AI recognize, interpret, and solve it instantly.</p>
        </header>

        <main class="grid grid-cols-1 lg:grid-cols-5 gap-8">
            
            <!-- Left Column: Canvas and Controls -->
            <div class="lg:col-span-3">
                <div class="relative bg-white rounded-2xl shadow-lg ring-1 ring-slate-200/50">
                    <!-- Placeholder -->
                    <div id="canvas-placeholder" class="absolute inset-0 flex items-center justify-center pointer-events-none transition-opacity duration-300">
                        <p class="text-slate-400 text-lg">Draw your equation here...</p>
                    </div>
                    <!-- Drawing Canvas -->
                    <canvas id="math-canvas" class="w-full h-auto rounded-t-2xl"></canvas>
                    
                    <!-- Controls -->
                    <div class="flex flex-wrap items-center gap-3 p-4 border-t border-slate-200/80 bg-slate-50/50 rounded-b-2xl">
                        <button id="recognize-btn" class="flex-grow sm:flex-grow-0 h-12 px-6 rounded-lg bg-gradient-to-r from-purple-600 to-indigo-600 text-white font-semibold text-base shadow-lg hover:shadow-xl hover:scale-105 disabled:bg-gradient-to-br disabled:from-slate-400 disabled:to-slate-400 disabled:shadow-md disabled:scale-100 transition-all duration-300 ease-in-out flex items-center justify-center gap-3">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="m21.64 3.64-1.28-1.28a1.21 1.21 0 0 0-1.72 0L2 18.59a1.21 1.21 0 0 0 0 1.72l1.28 1.28a1.21 1.21 0 0 0 1.72 0L21.64 5.36a1.21 1.21 0 0 0 0-1.72Z"></path><path d="m14 7 3 3"></path><path d="M5 6v4"></path><path d="M12 6v4"></path><path d="M19 6v4"></path><path d="M5 14h4"></path><path d="M12 14h4"></path><path d="M19 14h4"></path><path d="M5 22h4"></path><path d="M12 22h4"></path></svg>
                            <span class="btn-text">Recognize & Calculate</span>
                            <svg class="spinner hidden h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                        </button>
                        
                        <div class="flex gap-3 ml-auto">
                            <button id="undo-btn" title="Undo" class="w-11 h-11 flex items-center justify-center rounded-lg bg-slate-200 text-slate-600 hover:bg-slate-300 hover:text-slate-800 transition-all duration-200 shadow-sm">
                                <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 7v6h6"></path><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"></path></svg>
                            </button>
                            <button id="clear-btn" title="Clear" class="w-11 h-11 flex items-center justify-center rounded-lg bg-slate-200 text-slate-600 hover:bg-red-200 hover:text-red-700 transition-all duration-200 shadow-sm">
                                <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"></path><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Column: Results -->
            <div class="lg:col-span-2 space-y-6">
                <!-- Recognition Output Section -->
                <div class="p-5 bg-white rounded-2xl shadow-lg ring-1 ring-slate-200/50 h-fit">
                    <h3 class="font-semibold text-slate-900 text-lg">Recognition Output</h3>
                    <div class="mt-3 space-y-3">
                        <div class="flex items-center gap-3">
                            <strong class="text-sm w-20">Expression:</strong>
                            <div id="ocr-latex-output" class="min-h-[36px] flex items-center"><span class="text-slate-400">N/A</span></div>
                        </div>
                         <div class="flex items-start gap-3">
                            <strong class="text-sm w-20 pt-1.5">Plain Text:</strong>
                            <div class="bg-indigo-50 text-indigo-800 font-mono text-sm p-1.5 rounded-md w-full break-words">
                                <span id="ocr-plain-output" class="text-slate-400">N/A</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Result Section -->
                <div class="p-5 bg-white rounded-2xl shadow-lg ring-1 ring-slate-200/50 h-fit">
                  <h3 class="font-semibold text-slate-900 text-lg">Final Result</h3>
                  <div id="result-output" class="mt-3 p-4 bg-slate-100 rounded-lg min-h-[88px] flex flex-col items-center justify-center text-center">
                    <p id="result-description" class="text-sm font-medium text-slate-500 mb-2"></p>
                    <div id="result-value" class="text-2xl break-all">
                        <span class="text-slate-400 text-base font-normal">(no result yet)</span>
                    </div>
                  </div>
                </div>

                <!-- Step-by-step solution section -->
                <div id="solution-container" class="hidden p-5 bg-white rounded-2xl shadow-lg ring-1 ring-slate-200/50 h-fit">
                  <h3 class="font-semibold text-slate-900 text-lg">Step-by-Step Solution</h3>
                  <div id="solution-steps" class="mt-3 text-slate-700">
                      <span class="text-slate-400 text-base font-normal">(no solution yet)</span>
                  </div>
                </div>

                <!-- Error Display Section -->
                <div id="error-display" class="hidden mt-4 p-4 bg-red-100 border-l-4 border-red-500 text-red-800 rounded-r-lg text-sm"></div>
            </div>
            
        </main>
    </div>

    <script type="module">
        import { evaluate as mathEvaluate } from 'https://esm.sh/mathjs';
        import nerdamer from 'https://esm.sh/nerdamer/all.js';

        // --- DOM Element References ---
        const canvas = document.getElementById('math-canvas');
        const recognizeBtn = document.getElementById('recognize-btn');
        const undoBtn = document.getElementById('undo-btn');
        const clearBtn = document.getElementById('clear-btn');
        const ocrLatexOutput = document.getElementById('ocr-latex-output');
        const ocrPlainOutput = document.getElementById('ocr-plain-output');
        const resultOutput = document.getElementById('result-output');
        const resultDescription = document.getElementById('result-description');
        const resultValue = document.getElementById('result-value');
        const errorDisplay = document.getElementById('error-display');
        const canvasPlaceholder = document.getElementById('canvas-placeholder');
        const solutionContainer = document.getElementById('solution-container');
        const solutionSteps = document.getElementById('solution-steps');

        // --- State Variables ---
        let ctx = canvas.getContext('2d');
        let isDrawing = false;
        let strokes = [];
        let currentStroke = [];
        
        // --- Helper Functions ---
        function showError(message) {
            errorDisplay.textContent = `Error: ${message}`;
            errorDisplay.classList.remove('hidden');
        }

        function clearError() {
            errorDisplay.classList.add('hidden');
        }
        
        function updatePlaceholderVisibility() {
            canvasPlaceholder.classList.toggle('opacity-0', strokes.length > 0);
        }

        function setUIState(isLoading) {
            const buttonText = recognizeBtn.querySelector('.btn-text');
            const spinner = recognizeBtn.querySelector('.spinner');
            recognizeBtn.disabled = isLoading;
            
            if (isLoading) {
                buttonText.textContent = 'Calculating...';
                spinner.classList.remove('hidden');
            } else {
                buttonText.textContent = 'Recognize & Calculate';
                spinner.classList.add('hidden');
            }
        }

        // --- Drawing and Canvas Logic ---
        function redrawAllStrokes() {
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#1e293b'; // slate-800
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            if (strokes.length === 0) return;
            
            ctx.beginPath();
            for (const stroke of strokes) {
                if (!stroke || stroke.length < 1) continue;
                ctx.moveTo(stroke[0].x, stroke[0].y);
                for (let i = 1; i < stroke.length; i++) {
                    ctx.lineTo(stroke[i].x, stroke[i].y);
                }
            }
            ctx.stroke();
        }

        function resizeCanvas() {
            const { width } = canvas.getBoundingClientRect();
            // Maintain a consistent aspect ratio, e.g., 2:1
            const height = Math.min(width / 2, 400); 
            canvas.width = width;
            canvas.height = height;
            redrawAllStrokes();
        }

        function getPointer(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return { x: clientX - rect.left, y: clientY - rect.top };
        }

        function startDrawing(e) {
            e.preventDefault();
            isDrawing = true;
            const p = getPointer(e);
            currentStroke = [p];
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
        }

        function draw(e) {
            if (!isDrawing) return;
            e.preventDefault();
            const p = getPointer(e);
            currentStroke.push(p);
            ctx.lineTo(p.x, p.y);
            ctx.stroke();
        }

        function endDrawing(e) {
            if (!isDrawing) return;
            e.preventDefault();
            isDrawing = false;
            if (currentStroke.length > 1) { // Only add non-empty strokes
                strokes.push([...currentStroke]);
            }
            currentStroke = [];
            updatePlaceholderVisibility();
        }

        function clearCanvas() {
            strokes = [];
            ocrLatexOutput.innerHTML = '<span class="text-slate-400">N/A</span>';
            ocrPlainOutput.innerHTML = '<span class="text-slate-400">N/A</span>';
            resultDescription.textContent = '';
            resultValue.innerHTML = '<span class="text-slate-400 text-base font-normal">(no result yet)</span>';
            
            solutionContainer.classList.add('hidden');
            solutionSteps.innerHTML = '<span class="text-slate-400 text-base font-normal">(no solution yet)</span>';

            clearError();
            redrawAllStrokes();
            updatePlaceholderVisibility();
        }

        function undoLastStroke() {
            if (strokes.length > 0) {
                strokes.pop();
                redrawAllStrokes();
                updatePlaceholderVisibility();
            }
        }

        // --- Recognition and API Logic ---
        function captureBase64() {
            return canvas.toDataURL('image/png').split(',')[1];
        }

        async function recognizeImage(base64) {
            if (!base64 || strokes.length === 0) {
                return { error: 'Canvas is empty. Please draw an expression first.' };
            }
            const apiKey = "AIzaSyBMlMvJJ3X2ZiH3c-oLRaxP3l6U56QxYnM"; // API key is provided by the environment
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
            const prompt = `
                Analyze the image of a handwritten mathematical expression.
                Respond with a JSON object containing four fields: "text", "latex", "operation", and "solution".
                - The "text" field should be a plain text string suitable for a calculation engine (e.g., "x^2 + 2*x - 1"). Use '*' for multiplication.
                - The "latex" field should be the LaTeX representation for display (e.g., "x^2 + 2x - 1").
                - The "operation" field should be one of the following strings based on the user's intent: "evaluate", "simplify", "solve", "differentiate", "integrate".
                - The "solution" field should be a string containing a step-by-step explanation of how to solve the problem. Use Markdown-style newlines for each step, and enclose LaTeX expressions within single dollar signs for inline math (e.g., $ax^2+bx+c=0$) and double dollar signs for block math.
                If the image is empty or has no recognizable math, return null for all fields.`;
            const payload = {
                contents: [{ parts: [{ text: prompt }, { inlineData: { mimeType: "image/png", data: base64 } }] }],
                generationConfig: { responseMimeType: "application/json" }
            };

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) throw new Error(`API Error: ${response.status} ${response.statusText}`);
                const result = await response.json();
                const candidate = result.candidates?.[0];
                if (!candidate?.content?.parts?.[0]?.text) throw new Error('Invalid response from API.');
                const parsedJson = JSON.parse(candidate.content.parts[0].text);
                return { latex: parsedJson.latex, text: parsedJson.text, operation: parsedJson.operation, solution: parsedJson.solution };
            } catch (error) {
                console.error("Error recognizing image:", error);
                return { error: error.message || 'Failed to recognize image.' };
            }
        }

        function renderSolution(solutionText) {
            if (!solutionText) {
                solutionContainer.classList.add('hidden');
                return;
            }

            solutionSteps.innerHTML = ''; // Clear previous steps
            solutionContainer.classList.remove('hidden');

            const steps = solutionText.split('\n').filter(step => step.trim() !== '');

            steps.forEach(step => {
                const stepElement = document.createElement('div');
                stepElement.className = 'solution-step';

                // This regex will find text between $$...$$ or $...$
                const parts = step.split(/(\$\$[^`]+\$\$|\$[^\$`]+\$)/g);

                parts.forEach(part => {
                    if (part.startsWith('$') && part.endsWith('$')) {
                        const span = document.createElement('span');
                        const isBlock = part.startsWith('$$');
                        const latex = part.slice(isBlock ? 2 : 1, isBlock ? -2 : -1);
                        try {
                            katex.render(latex, span, {
                                throwOnError: false,
                                displayMode: isBlock
                            });
                        } catch (e) {
                            console.error("KaTeX rendering error:", e);
                            span.textContent = part; // Fallback to text
                        }
                        stepElement.appendChild(span);
                    } else {
                        // Sanitize plain text parts to prevent HTML injection
                        stepElement.appendChild(document.createTextNode(part));
                    }
                });
                
                solutionSteps.appendChild(stepElement);
            });
        }
        
        // --- Mathematical Operations ---
        function handleOperation(op, expr) {
            clearError();
            resultDescription.textContent = '';
            resultValue.innerHTML = '';
            
            try {
                if (!expr) {
                    throw new Error('No expression to operate on.');
                }
                
                let nerdamerResult;
                let descriptionText = '';

                switch (op) {
                    case 'evaluate':
                        descriptionText = 'The expression evaluates to:';
                        const evalResult = mathEvaluate(expr);
                        nerdamerResult = nerdamer(evalResult.toString());
                        break;
                    case 'simplify':
                        descriptionText = 'The simplified form is:';
                        nerdamerResult = nerdamer.simplify(expr);
                        break;
                    case 'differentiate':
                        descriptionText = 'The derivative with respect to x is:';
                        nerdamerResult = nerdamer(`diff(${expr}, x)`);
                        break;
                    case 'integrate':
                        descriptionText = 'The integral with respect to x is:';
                        nerdamerResult = nerdamer(`integrate(${expr}, x)`);
                        break;
                    case 'solve':
                        descriptionText = 'The solution for x is:';
                        nerdamerResult = nerdamer.solve(expr, 'x');
                        break;
                    default:
                        throw new Error(`Operation '${op}' not recognized. Try simplifying.`);
                }
                
                resultDescription.textContent = descriptionText;
                const latexResult = nerdamerResult.toTeX();
                katex.render(latexResult, resultValue, {
                    throwOnError: false,
                    displayMode: true
                });

            } catch (e) {
                showError(e.message || 'Calculation failed.');
                resultDescription.textContent = '';
                resultValue.innerHTML = '<span class="text-slate-400 text-base font-normal">(calculation failed)</span>';
            }
        }

        async function handleRecognizeAndCalculate() {
            setUIState(true);
            clearError();
            solutionContainer.classList.add('hidden');
            
            const base64 = captureBase64();
            const resp = await recognizeImage(base64);

            if (resp.error) {
                showError(resp.error);
                ocrLatexOutput.innerHTML = '<span class="text-slate-400">N/A</span>';
                ocrPlainOutput.innerHTML = '<span class="text-slate-400">N/A</span>';
            } else {
                if (resp.latex) {
                    katex.render(resp.latex, ocrLatexOutput, { throwOnError: false });
                } else {
                    ocrLatexOutput.innerHTML = '<span class="text-slate-400">N/A</span>';
                }

                ocrPlainOutput.textContent = resp.text ?? 'N/A';
                
                if (resp.solution) {
                    renderSolution(resp.solution);
                }

                if (resp.operation && resp.text) {
                    handleOperation(resp.operation, resp.text);
                } else if(resp.text) {
                     showError("Could not determine an operation. Please try drawing a clearer expression.");
                }
            }
            setUIState(false);
        }

        // --- Initialization and Event Listeners ---
        function initialize() {
            // Canvas listeners
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', endDrawing);
            canvas.addEventListener('mouseleave', endDrawing);
            canvas.addEventListener('touchstart', startDrawing, { passive: false });
            canvas.addEventListener('touchmove', draw, { passive: false });
            canvas.addEventListener('touchend', endDrawing);

            // Button listeners
            recognizeBtn.addEventListener('click', handleRecognizeAndCalculate);
            undoBtn.addEventListener('click', undoLastStroke);
            clearBtn.addEventListener('click', clearCanvas);
            
            // Initial canvas setup
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            updatePlaceholderVisibility();
        }

        // Run the app
        initialize();
    </script>
</body>
</html>


